/* 
 * This file is part of the CK2MapTools distribution.
 * Copyright (c) 2018 Lo√Øc Visse.
 * 
 * This program is free software: you can redistribute it and/or modify  
 * it under the terms of the GNU General Public License as published by  
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
*/


package ck2maptools.main;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;

import ck2maptools.data.Coordinates;
import ck2maptools.data.InputFile;
import ck2maptools.data.Loader;
import ck2maptools.data.OutputFile;
import ck2maptools.data.Province;
import ck2maptools.utils.Logger;
import ck2maptools.utils.Utils;

public class CK2MakeTradeRoutes implements ICK2MapTool {

	private Loader loader;
	
	private BufferedImage bufInTradeRoute;

	private List<File> filInTradeRoutes;
	private List<Province> tradeRouteProvinces; //Set of all provinces a trade route goes through

	//A list of coordinates that are the starting points of a trade route segment, for the next iteration 
	private List<List<Coordinates>> tradeRouteSegmentList;
	//Coordinates of every trade route pixel that has been iterated upon (so we don't run a pixel twice)
	private List<Coordinates> reconstructedList;

	private int returnCode;
	
	public static InputFile[] inputFiles() {
		return new InputFile[]{
				InputFile.Settlements,
				InputFile.Provinces
		};
	}
	
	public static InputFile[] inputFilesOptional() {
		return new InputFile[]{
		};
	}

	public static OutputFile[] outputFiles() {
		return new OutputFile[]{
				//Trade_routes //TODO
		};
	}
	
	public static void main(String[] args) throws Exception {
		new CK2MakeTradeRoutes().execute();
	}
	
	public int execute() throws Exception {
		returnCode = ERROR_NONE;
		long ms = System.currentTimeMillis();
		Logger.InitLogger("CK2MakeTradeRoutes");
		
		Utils.checkCriticalResources(inputFiles(), true);
		
		//Load the input map
		loader = Loader.getLoader();
		loader.loadSettlements();
		loader.loadProvinces(true, false);

		

		filInTradeRoutes = new ArrayList<File>();
		
		//Search for input trade_route maps
		File inputFolder = new File("./input");
		for (File inputMap : inputFolder.listFiles())
		{
			//ignore the template
			if (inputMap.getName().equals("trade_route_template.bmp"))
				continue;
			
			if (inputMap.getName().length() > 12 && inputMap.getName().substring(0, 12).equals("trade_route_"))
			{
				Logger.log("Found input map : " + inputMap.getName());
				filInTradeRoutes.add(inputMap);
			}
		}
		
		//Do we even have any trade route input maps to work with ?
		if (filInTradeRoutes.size() == 0)
		{
			Logger.log("ERROR: No trade_route_*.bmp map found");
			Logger.close();
			return returnCode|ERROR_TRADE_ROUTES;
		}
		
		//Load the template if present : update trade route bitmaps with it if necessary
		BufferedImage bufInTemplate = null;
		try {
			bufInTemplate = (BufferedImage) Utils.readInputImage("./input/trade_route_template.bmp");
		}
		catch (IOException e)
		{}
				
		
		//Setup output dirs if they don't exist
		File outputDirTradeRoutes = Utils.mkDir("./output/common/trade_routes");
		File outputDirScriptedTriggers = Utils.mkDir("./output/common/scripted_triggers");
		
		File tradeRouteTriggers = new File(outputDirScriptedTriggers + "/autogenerated_trade_route_triggers.txt");
		Logger.log("Writing "+tradeRouteTriggers.getPath());
		Writer triggerWriter = new FileWriter(tradeRouteTriggers);

		//For each trade route input map found earlier...
		for (File inputMap : filInTradeRoutes)
		{
			String tradeRouteName = inputMap.getName().substring(12, inputMap.getName().length() - 4);
			Logger.log("Parsing trade_route "+tradeRouteName+"...",0);	
			
			bufInTradeRoute = (BufferedImage) Utils.readInputImage(inputMap.getPath());
			
			
			//Init static variables for this map
			tradeRouteSegmentList = new ArrayList<List<Coordinates>>();
			reconstructedList = new ArrayList<Coordinates>();	
			List<Province> tradePostProvinces = new ArrayList<Province>();
			
			for (int x=0; x<loader.sizeX; x++)
				for(int y=0; y<loader.sizeY; y++)
				{
					boolean left, right, up, down, ld, lu, rd, ru;
					left = isTradeRouteWhatever(x-1,y);
					right = isTradeRouteWhatever(x+1,y);
					up = isTradeRouteWhatever(x,y-1);
					down = isTradeRouteWhatever(x,y+1);
					ld = isTradeRouteWhatever(x-1,y+1);
					lu = isTradeRouteWhatever(x-1,y-1);
					rd = isTradeRouteWhatever(x+1,y+1);
					ru = isTradeRouteWhatever(x+1,y-1);
					
					
					//Find the trade route's starting points
					if (isTradeRouteStart(x,y))
					{
						//Create a new segment
						List<Coordinates> segment = new ArrayList<Coordinates>();
						segment.add(new Coordinates(x,y));
						//Add it to the list
						tradeRouteSegmentList.add(segment);
					}
					
					//Find the trade route's trade posts, this is where trade posts will be displayed / buildable by default
					if (isTradeRouteTradePost(x,y))
					{

						//Add it to the list
						Province tradeProvince = loader.provinceColorMap.get(loader.bufInProvinces.getRGB(x, y));
						if (tradeProvince!= null && !tradePostProvinces.contains(tradeProvince))
							tradePostProvinces.add(tradeProvince);
					}
					
					//Fix up the corners of the trade route
					//Empty pixel ?
					if (!isTradeRouteWhatever(x,y))
					{
						//If it's just in a corner between 2 other trade route pixels, make that part of the trade route as well, this will simplify calculations
						//later as we no longer need to account for "diagonals", only the pixels left, right, up and down
						if ((left && up && !lu && !right && !down) ||
								(left && down && !ld && !right && !up) ||
								(right && up && !ru && !left && !down) ||
								(right && down && !rd && !left && !up))
							bufInTradeRoute.setRGB(x, y, Color.white.getRGB());
						else
							bufInTradeRoute.setRGB(x, y, bufInTemplate.getRGB(x, y)); //Otherwise copy the template
					}
					
				}
			

			//Overwrite the image with the fixed up corners, and template
			Utils.writeOutputImage(inputMap.getPath(), bufInTradeRoute);
			
			
			//Initialize the output file
			File tradeRouteFile = new File(outputDirTradeRoutes + "/" + tradeRouteName+".txt");
			Logger.log("Writing "+tradeRouteFile.getPath(),0);
			Writer writer = new FileWriter(tradeRouteFile);
			
			//Basic writeup of the output file
			writer.write(tradeRouteName+" = {\r\n");
			
			//Trigger for displaying trade posts :
			
			writer.write("\ttrade_post_display_trigger = {\r\n");
			if (tradePostProvinces.size() != 0)
			{
				triggerWriter.write(tradeRouteName+"_trade_post_display_trigger = {\r\n");
				triggerWriter.write("\tOR = {\r\n");
				for (Province tp : tradePostProvinces)
				{
					triggerWriter.write("\t\tprovince_id = "+ tp.getIndex() +"\r\n");
				}
				triggerWriter.write("\t}\r\n");
				triggerWriter.write("}\r\n\r\n");
				
				writer.write("\t\t"+tradeRouteName+"_trade_post_display_trigger =  yes\r\n");
			}
			else
			{
				writer.write("\t\talways = yes\r\n");
			}
			writer.write("\t}\r\n");
			writer.write("\t\r\n");
			
			writer.write("\tmodifier = {\t# How the trade route modifies the provinces it passes\r\n");
			writer.write("\t\tcastle_tax_modifier = 0.10\r\n");
			writer.write("\t\tcity_tax_modifier = 0.10\r\n");
			writer.write("\t\ttemple_tax_modifier = 0.10\r\n");
			writer.write("\t\ttribal_tax_modifier = 0.10\r\n");
			writer.write("\t\ttrade_route_value = 15\r\n");
			writer.write("\t\tlocal_movement_speed = 0.20\r\n");
			writer.write("\t\ttech_growth_modifier = 0.20\r\n");
			writer.write("\t\ticon = 4\r\n");
			writer.write("\t}\r\n");
			writer.write("\t\r\n");
			
			writer.write("\tstart = {				# Start provinces of trade route\r\n");				
			triggerWriter.write(tradeRouteName+"_trade_route_start_trigger = {\r\n");
			triggerWriter.write("\tOR = {\r\n");

			for (List<Coordinates> segment : tradeRouteSegmentList)
			{
				Coordinates start = segment.get(0);
				Province provinceStart = loader.provinceColorMap.get(loader.bufInProvinces.getRGB(start.getX(), start.getY()));
				writer.write("\t\t"+provinceStart.getIndex()+"\r\n");
				triggerWriter.write("\t\tprovince_id = "+ provinceStart.getIndex() +"\r\n");
			}
			writer.write("\t}\r\n");
			writer.write("\t\r\n");
			triggerWriter.write("\t}\r\n");
			triggerWriter.write("}\r\n\r\n");
			
			tradeRouteProvinces = new ArrayList<Province>();
			
			//Reconstruct Trade Route Segments
			Logger.log("Reconstructing Trade Route...",0);
			int step = 0;
			while(!tradeRouteSegmentList.isEmpty())
			{
				step++;
				Logger.log("Step "+step+"...");
				tradeRouteSegmentList = reconstructTradeRoutes(tradeRouteSegmentList, writer);
			}

			writer.write("\r\n\twealth = "+(tradeRouteProvinces.size())+" # Total base wealth of "+tradeRouteName+"\r\n\r\n");
			

			writer.write("}\r\n");
			writer.close();
		}
		
		triggerWriter.close();

		
		Logger.log("Done in "+(System.currentTimeMillis()-ms)+"ms");
		Logger.close();
		return returnCode;
	}
	
	private boolean isTradeRoutePath(int x, int y)
	{
		if (!Coordinates.isValidCoordinates(x, y))
			return false;
		
		return bufInTradeRoute.getRGB(x, y) == Color.white.getRGB();
	}
	
	private boolean isTradeRouteStart(int x, int y)
	{
		if (!Coordinates.isValidCoordinates(x, y))
			return false;
	
		return bufInTradeRoute.getRGB(x, y) == Color.green.getRGB();
	}
	
	private boolean isTradeRouteNode(int x, int y)
	{
		if (!Coordinates.isValidCoordinates(x, y))
			return false;
		
		return ( bufInTradeRoute.getRGB(x, y) == Color.red.getRGB() || bufInTradeRoute.getRGB(x, y) == Color.blue.getRGB() );
	}
	
	private boolean isTradeRouteWhatever(int x, int y)
	{
		if (!Coordinates.isValidCoordinates(x, y))
			return false;
		
		return (isTradeRoutePath(x, y) || isTradeRouteStart(x, y) || isTradeRouteNode(x, y) );
	}
	
	private boolean isTradeRouteTradePost(int x, int y)
	{
		if (!Coordinates.isValidCoordinates(x, y))
			return false;
		
		return bufInTradeRoute.getRGB(x, y) == Color.red.getRGB();
	}
	
	
	//Attempts to move along the path drawn on the trade_route bitmap, starting from the coordinates in the parameters.
	//Each pixel successfully navigated to is added to the trade route segment it belongs to, and to the global reconstructedList
	//The parameter is a list of all trade route segments (which are themselves a list of coordinates : one for each pixel they are made of) that have been reconstructed or are scheduled for reconstruction.
	//Initially the list only contains one point for each of the starting paths, and these will be the first segments to be reconstructed.
	//As more nodes are encountered, new segments get scheduled for reconstruction, until nothing new can be reached
	private List<List<Coordinates>> reconstructTradeRoutes(List<List<Coordinates>> entryList, Writer tradeRouteWriter) throws IOException
	{
		//Initialize return variable
		List<List<Coordinates>> retList = new ArrayList<List<Coordinates>>();
		
		//For every segment in the list...
		for (List<Coordinates> segment : entryList)
		{
			//Get the first point in this segment
			Coordinates start = segment.get(0);
			int x = start.getX(), y=start.getY();
			
			Province currentProvince = loader.provinceColorMap.get(loader.bufInProvinces.getRGB(x, y));

			if (!reconstructedList.contains(start))
			{
				reconstructedList.add(start);
			
				//Is this a new segment of the trade route ? (don't do this if we're on a starting position, as it will not iterate beyond the first pixel)
				if (isTradeRoutePath(x, y))
				{
					//Write to the file
					tradeRouteWriter.write("\tpath = { #"+x+";"+y+"\r\n");
					tradeRouteWriter.write("\t\t"+currentProvince.getIndex());
					if (!tradeRouteProvinces.contains(currentProvince))
						tradeRouteProvinces.add(currentProvince);
				}
			}
			else
			{
				//Is this a new segment of the trade route ? (don't do this if we're on a starting position, as it will not iterate beyond the first pixel)
				//Looks like this path has already been covered, but it wasn't when we were added, this can happen when roads merge.
				//Simply skip the whole segment, nothing to do here
				if (isTradeRoutePath(x, y))
				{
					continue;
				}
			}

			boolean found = false;
			
			do {
				found = false;
				
				//Look for every neighbouring pixel
				Coordinates left=null, right=null, up=null, down=null, next=null;
				List<Coordinates> neighbours = new ArrayList<Coordinates>();

				if (x>0)
					left = new Coordinates(x-1,y);
				if (x<loader.sizeX)
					right = new Coordinates(x+1,y);
				if (y>0)
					up = new Coordinates(x,y-1);
				if (y<loader.sizeY)
					down = new Coordinates(x,y+1);
				
				//If we haven't checked that out yet, consider it a valid neighbour
				if (!segment.contains(left) && !reconstructedList.contains(left))
					neighbours.add(left);
				if (!segment.contains(right) && !reconstructedList.contains(right))
					neighbours.add(right);
				if (!segment.contains(up) && !reconstructedList.contains(up))
					neighbours.add(up);
				if (!segment.contains(down) && !reconstructedList.contains(down))
					neighbours.add(down);
				
				for (Coordinates c : neighbours)
				{
					//We're currently on a path
					if (isTradeRoutePath(x, y))
					{
						//An unexplored point is found
						if (c != null && isTradeRouteWhatever(c.getX(), c.getY()))
						{
							if (next == null)
							{
								//Make that our next move
								next = c;
								found = true;
	
								//Add it to the segment and to the list of already checked pixels 
								segment.add(next);
								reconstructedList.add(next);
							}
							else
							{
								Logger.log("Trade Route error at coordinates "+x+";"+y+" : found multiple possible paths");
								returnCode |= ERROR_TRADE_ROUTES;
							}
						}
					}
					//Just starting out or encountered a node, this is the end of this segment
					//Find unexplored neighbours of that node and mark them as future segments
					else if (isTradeRouteNode(x, y) || isTradeRouteStart(x, y))
					{
						//An unexplored point is found
						if (c != null && isTradeRoutePath(c.getX(), c.getY()))
						{
							ArrayList<Coordinates> futureSegment = new ArrayList<Coordinates>();
							futureSegment.add(c);
							retList.add(futureSegment); //To be done next round
						}
					}

				}
				
				if (found)
				{
					x = next.getX(); y=next.getY();
					

					Province nextProvince = loader.provinceColorMap.get(loader.bufInProvinces.getRGB(x, y));
				
					//If the route moved into a new province, add it in the file 
					if (nextProvince != null &&  
							nextProvince != currentProvince &&
							!nextProvince.isWater() && 
							!nextProvince.isWasteland()
						)
					{
						currentProvince = nextProvince;
						tradeRouteWriter.write(" "+currentProvince.getIndex());
						if (!tradeRouteProvinces.contains(currentProvince))
							tradeRouteProvinces.add(currentProvince);
					}

				}
				else
				{
					//We've reached a node / the end of this segment, write to file to close the bracket
					if (!isTradeRouteStart(x, y))
					{
						//Write to the file
						tradeRouteWriter.write("\r\n");
						tradeRouteWriter.write("\t} #"+x+";"+y+"\r\n");
					}
				}
			
			}
			while (found);
		} //next segment
		
		return retList;
	}
}
